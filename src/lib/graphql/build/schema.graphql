schema {
  query: query_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
columns and relationships of "BondingCurve"
"""
type BondingCurve {
  bcType: String
  buyFee: numeric
  buyReserveRatio: numeric
  chainId: Int!
  collateralToken: String
  collateralTokenDecimals: Int
  db_write_timestamp: timestamp

  """An array relationship"""
  feeClaim(
    """distinct select on columns"""
    distinct_on: [FeeClaim_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [FeeClaim_order_by!]

    """filter the rows returned"""
    where: FeeClaim_bool_exp
  ): [FeeClaim!]!
  id: String!
  issuanceToken: String
  issuanceTokenDecimals: Int
  sellFee: numeric
  sellReserveRatio: numeric

  """An array relationship"""
  swaps(
    """distinct select on columns"""
    distinct_on: [Swap_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Swap_order_by!]

    """filter the rows returned"""
    where: Swap_bool_exp
  ): [Swap!]!
  virtualCollateral: numeric
  virtualCollateralRaw: numeric
  virtualIssuance: numeric

  """An object relationship"""
  workflow: Workflow
  workflow_id: String!
}

"""
Boolean expression to filter rows from the table "BondingCurve". All fields are combined with a logical 'AND'.
"""
input BondingCurve_bool_exp {
  _and: [BondingCurve_bool_exp!]
  _not: BondingCurve_bool_exp
  _or: [BondingCurve_bool_exp!]
  bcType: String_comparison_exp
  buyFee: numeric_comparison_exp
  buyReserveRatio: numeric_comparison_exp
  chainId: Int_comparison_exp
  collateralToken: String_comparison_exp
  collateralTokenDecimals: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  feeClaim: FeeClaim_bool_exp
  id: String_comparison_exp
  issuanceToken: String_comparison_exp
  issuanceTokenDecimals: Int_comparison_exp
  sellFee: numeric_comparison_exp
  sellReserveRatio: numeric_comparison_exp
  swaps: Swap_bool_exp
  virtualCollateral: numeric_comparison_exp
  virtualCollateralRaw: numeric_comparison_exp
  virtualIssuance: numeric_comparison_exp
  workflow: Workflow_bool_exp
  workflow_id: String_comparison_exp
}

"""Ordering options when selecting data from "BondingCurve"."""
input BondingCurve_order_by {
  bcType: order_by
  buyFee: order_by
  buyReserveRatio: order_by
  chainId: order_by
  collateralToken: order_by
  collateralTokenDecimals: order_by
  db_write_timestamp: order_by
  feeClaim_aggregate: FeeClaim_aggregate_order_by
  id: order_by
  issuanceToken: order_by
  issuanceTokenDecimals: order_by
  sellFee: order_by
  sellReserveRatio: order_by
  swaps_aggregate: Swap_aggregate_order_by
  virtualCollateral: order_by
  virtualCollateralRaw: order_by
  virtualIssuance: order_by
  workflow: Workflow_order_by
  workflow_id: order_by
}

"""
select columns of table "BondingCurve"
"""
enum BondingCurve_select_column {
  """column name"""
  bcType

  """column name"""
  buyFee

  """column name"""
  buyReserveRatio

  """column name"""
  chainId

  """column name"""
  collateralToken

  """column name"""
  collateralTokenDecimals

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  issuanceToken

  """column name"""
  issuanceTokenDecimals

  """column name"""
  sellFee

  """column name"""
  sellReserveRatio

  """column name"""
  virtualCollateral

  """column name"""
  virtualCollateralRaw

  """column name"""
  virtualIssuance

  """column name"""
  workflow_id
}

"""
Streaming cursor of the table "BondingCurve"
"""
input BondingCurve_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: BondingCurve_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input BondingCurve_stream_cursor_value_input {
  bcType: String
  buyFee: numeric
  buyReserveRatio: numeric
  chainId: Int
  collateralToken: String
  collateralTokenDecimals: Int
  db_write_timestamp: timestamp
  id: String
  issuanceToken: String
  issuanceTokenDecimals: Int
  sellFee: numeric
  sellReserveRatio: numeric
  virtualCollateral: numeric
  virtualCollateralRaw: numeric
  virtualIssuance: numeric
  workflow_id: String
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
columns and relationships of "FeeClaim"
"""
type FeeClaim {
  amount: numeric!
  blockTimestamp: Int!

  """An object relationship"""
  bondingCurve: BondingCurve
  bondingCurve_id: String!
  chainId: Int!
  db_write_timestamp: timestamp
  id: String!
  recipient: String!
}

"""
order by aggregate values of table "FeeClaim"
"""
input FeeClaim_aggregate_order_by {
  avg: FeeClaim_avg_order_by
  count: order_by
  max: FeeClaim_max_order_by
  min: FeeClaim_min_order_by
  stddev: FeeClaim_stddev_order_by
  stddev_pop: FeeClaim_stddev_pop_order_by
  stddev_samp: FeeClaim_stddev_samp_order_by
  sum: FeeClaim_sum_order_by
  var_pop: FeeClaim_var_pop_order_by
  var_samp: FeeClaim_var_samp_order_by
  variance: FeeClaim_variance_order_by
}

"""
order by avg() on columns of table "FeeClaim"
"""
input FeeClaim_avg_order_by {
  amount: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
Boolean expression to filter rows from the table "FeeClaim". All fields are combined with a logical 'AND'.
"""
input FeeClaim_bool_exp {
  _and: [FeeClaim_bool_exp!]
  _not: FeeClaim_bool_exp
  _or: [FeeClaim_bool_exp!]
  amount: numeric_comparison_exp
  blockTimestamp: Int_comparison_exp
  bondingCurve: BondingCurve_bool_exp
  bondingCurve_id: String_comparison_exp
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  recipient: String_comparison_exp
}

"""
order by max() on columns of table "FeeClaim"
"""
input FeeClaim_max_order_by {
  amount: order_by
  blockTimestamp: order_by
  bondingCurve_id: order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  recipient: order_by
}

"""
order by min() on columns of table "FeeClaim"
"""
input FeeClaim_min_order_by {
  amount: order_by
  blockTimestamp: order_by
  bondingCurve_id: order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  recipient: order_by
}

"""Ordering options when selecting data from "FeeClaim"."""
input FeeClaim_order_by {
  amount: order_by
  blockTimestamp: order_by
  bondingCurve: BondingCurve_order_by
  bondingCurve_id: order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  recipient: order_by
}

"""
select columns of table "FeeClaim"
"""
enum FeeClaim_select_column {
  """column name"""
  amount

  """column name"""
  blockTimestamp

  """column name"""
  bondingCurve_id

  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  recipient
}

"""
order by stddev() on columns of table "FeeClaim"
"""
input FeeClaim_stddev_order_by {
  amount: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
order by stddev_pop() on columns of table "FeeClaim"
"""
input FeeClaim_stddev_pop_order_by {
  amount: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
order by stddev_samp() on columns of table "FeeClaim"
"""
input FeeClaim_stddev_samp_order_by {
  amount: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
Streaming cursor of the table "FeeClaim"
"""
input FeeClaim_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: FeeClaim_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input FeeClaim_stream_cursor_value_input {
  amount: numeric
  blockTimestamp: Int
  bondingCurve_id: String
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  recipient: String
}

"""
order by sum() on columns of table "FeeClaim"
"""
input FeeClaim_sum_order_by {
  amount: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
order by var_pop() on columns of table "FeeClaim"
"""
input FeeClaim_var_pop_order_by {
  amount: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
order by var_samp() on columns of table "FeeClaim"
"""
input FeeClaim_var_samp_order_by {
  amount: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
order by variance() on columns of table "FeeClaim"
"""
input FeeClaim_variance_order_by {
  amount: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
columns and relationships of "LinearVesting"
"""
type LinearVesting {
  amountRaw: numeric!
  blockTimestamp: Int!
  chainId: Int!
  cliff: numeric!
  db_write_timestamp: timestamp
  end: numeric!
  id: String!
  recipient: String!
  start: numeric!
  status: vestingstatus!

  """An object relationship"""
  streamingPaymentProcessor: StreamingPaymentProcessor
  streamingPaymentProcessor_id: String!
  token: String!
}

"""
order by aggregate values of table "LinearVesting"
"""
input LinearVesting_aggregate_order_by {
  avg: LinearVesting_avg_order_by
  count: order_by
  max: LinearVesting_max_order_by
  min: LinearVesting_min_order_by
  stddev: LinearVesting_stddev_order_by
  stddev_pop: LinearVesting_stddev_pop_order_by
  stddev_samp: LinearVesting_stddev_samp_order_by
  sum: LinearVesting_sum_order_by
  var_pop: LinearVesting_var_pop_order_by
  var_samp: LinearVesting_var_samp_order_by
  variance: LinearVesting_variance_order_by
}

"""
order by avg() on columns of table "LinearVesting"
"""
input LinearVesting_avg_order_by {
  amountRaw: order_by
  blockTimestamp: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
}

"""
Boolean expression to filter rows from the table "LinearVesting". All fields are combined with a logical 'AND'.
"""
input LinearVesting_bool_exp {
  _and: [LinearVesting_bool_exp!]
  _not: LinearVesting_bool_exp
  _or: [LinearVesting_bool_exp!]
  amountRaw: numeric_comparison_exp
  blockTimestamp: Int_comparison_exp
  chainId: Int_comparison_exp
  cliff: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  end: numeric_comparison_exp
  id: String_comparison_exp
  recipient: String_comparison_exp
  start: numeric_comparison_exp
  status: vestingstatus_comparison_exp
  streamingPaymentProcessor: StreamingPaymentProcessor_bool_exp
  streamingPaymentProcessor_id: String_comparison_exp
  token: String_comparison_exp
}

"""
order by max() on columns of table "LinearVesting"
"""
input LinearVesting_max_order_by {
  amountRaw: order_by
  blockTimestamp: order_by
  chainId: order_by
  cliff: order_by
  db_write_timestamp: order_by
  end: order_by
  id: order_by
  recipient: order_by
  start: order_by
  status: order_by
  streamingPaymentProcessor_id: order_by
  token: order_by
}

"""
order by min() on columns of table "LinearVesting"
"""
input LinearVesting_min_order_by {
  amountRaw: order_by
  blockTimestamp: order_by
  chainId: order_by
  cliff: order_by
  db_write_timestamp: order_by
  end: order_by
  id: order_by
  recipient: order_by
  start: order_by
  status: order_by
  streamingPaymentProcessor_id: order_by
  token: order_by
}

"""Ordering options when selecting data from "LinearVesting"."""
input LinearVesting_order_by {
  amountRaw: order_by
  blockTimestamp: order_by
  chainId: order_by
  cliff: order_by
  db_write_timestamp: order_by
  end: order_by
  id: order_by
  recipient: order_by
  start: order_by
  status: order_by
  streamingPaymentProcessor: StreamingPaymentProcessor_order_by
  streamingPaymentProcessor_id: order_by
  token: order_by
}

"""
select columns of table "LinearVesting"
"""
enum LinearVesting_select_column {
  """column name"""
  amountRaw

  """column name"""
  blockTimestamp

  """column name"""
  chainId

  """column name"""
  cliff

  """column name"""
  db_write_timestamp

  """column name"""
  end

  """column name"""
  id

  """column name"""
  recipient

  """column name"""
  start

  """column name"""
  status

  """column name"""
  streamingPaymentProcessor_id

  """column name"""
  token
}

"""
order by stddev() on columns of table "LinearVesting"
"""
input LinearVesting_stddev_order_by {
  amountRaw: order_by
  blockTimestamp: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
}

"""
order by stddev_pop() on columns of table "LinearVesting"
"""
input LinearVesting_stddev_pop_order_by {
  amountRaw: order_by
  blockTimestamp: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
}

"""
order by stddev_samp() on columns of table "LinearVesting"
"""
input LinearVesting_stddev_samp_order_by {
  amountRaw: order_by
  blockTimestamp: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
}

"""
Streaming cursor of the table "LinearVesting"
"""
input LinearVesting_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: LinearVesting_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input LinearVesting_stream_cursor_value_input {
  amountRaw: numeric
  blockTimestamp: Int
  chainId: Int
  cliff: numeric
  db_write_timestamp: timestamp
  end: numeric
  id: String
  recipient: String
  start: numeric
  status: vestingstatus
  streamingPaymentProcessor_id: String
  token: String
}

"""
order by sum() on columns of table "LinearVesting"
"""
input LinearVesting_sum_order_by {
  amountRaw: order_by
  blockTimestamp: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
}

"""
order by var_pop() on columns of table "LinearVesting"
"""
input LinearVesting_var_pop_order_by {
  amountRaw: order_by
  blockTimestamp: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
}

"""
order by var_samp() on columns of table "LinearVesting"
"""
input LinearVesting_var_samp_order_by {
  amountRaw: order_by
  blockTimestamp: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
}

"""
order by variance() on columns of table "LinearVesting"
"""
input LinearVesting_variance_order_by {
  amountRaw: order_by
  blockTimestamp: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
}

"""
columns and relationships of "StreamingPaymentProcessor"
"""
type StreamingPaymentProcessor {
  chainId: Int!
  db_write_timestamp: timestamp
  id: String!

  """An array relationship"""
  vestings(
    """distinct select on columns"""
    distinct_on: [LinearVesting_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [LinearVesting_order_by!]

    """filter the rows returned"""
    where: LinearVesting_bool_exp
  ): [LinearVesting!]!

  """An object relationship"""
  workflow: Workflow
  workflow_id: String!
}

"""
Boolean expression to filter rows from the table "StreamingPaymentProcessor". All fields are combined with a logical 'AND'.
"""
input StreamingPaymentProcessor_bool_exp {
  _and: [StreamingPaymentProcessor_bool_exp!]
  _not: StreamingPaymentProcessor_bool_exp
  _or: [StreamingPaymentProcessor_bool_exp!]
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  vestings: LinearVesting_bool_exp
  workflow: Workflow_bool_exp
  workflow_id: String_comparison_exp
}

"""Ordering options when selecting data from "StreamingPaymentProcessor"."""
input StreamingPaymentProcessor_order_by {
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  vestings_aggregate: LinearVesting_aggregate_order_by
  workflow: Workflow_order_by
  workflow_id: order_by
}

"""
select columns of table "StreamingPaymentProcessor"
"""
enum StreamingPaymentProcessor_select_column {
  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  workflow_id
}

"""
Streaming cursor of the table "StreamingPaymentProcessor"
"""
input StreamingPaymentProcessor_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: StreamingPaymentProcessor_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input StreamingPaymentProcessor_stream_cursor_value_input {
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  workflow_id: String
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [String!]

  """does the array contain the given value"""
  _contains: [String!]
  _eq: [String!]
  _gt: [String!]
  _gte: [String!]
  _in: [[String!]!]
  _is_null: Boolean
  _lt: [String!]
  _lte: [String!]
  _neq: [String!]
  _nin: [[String!]!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "Swap"
"""
type Swap {
  blockTimestamp: Int!

  """An object relationship"""
  bondingCurve: BondingCurve
  bondingCurve_id: String!
  chainId: Int!
  collateralAmount: numeric!
  collateralToken: String!
  db_write_timestamp: timestamp
  id: String!
  initiator: String!
  issuanceAmount: numeric!
  issuanceToken: String!
  priceInCol: numeric!
  recipient: String!
  swapType: swaptype!
}

"""
order by aggregate values of table "Swap"
"""
input Swap_aggregate_order_by {
  avg: Swap_avg_order_by
  count: order_by
  max: Swap_max_order_by
  min: Swap_min_order_by
  stddev: Swap_stddev_order_by
  stddev_pop: Swap_stddev_pop_order_by
  stddev_samp: Swap_stddev_samp_order_by
  sum: Swap_sum_order_by
  var_pop: Swap_var_pop_order_by
  var_samp: Swap_var_samp_order_by
  variance: Swap_variance_order_by
}

"""
order by avg() on columns of table "Swap"
"""
input Swap_avg_order_by {
  blockTimestamp: order_by
  chainId: order_by
  collateralAmount: order_by
  issuanceAmount: order_by
  priceInCol: order_by
}

"""
Boolean expression to filter rows from the table "Swap". All fields are combined with a logical 'AND'.
"""
input Swap_bool_exp {
  _and: [Swap_bool_exp!]
  _not: Swap_bool_exp
  _or: [Swap_bool_exp!]
  blockTimestamp: Int_comparison_exp
  bondingCurve: BondingCurve_bool_exp
  bondingCurve_id: String_comparison_exp
  chainId: Int_comparison_exp
  collateralAmount: numeric_comparison_exp
  collateralToken: String_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  initiator: String_comparison_exp
  issuanceAmount: numeric_comparison_exp
  issuanceToken: String_comparison_exp
  priceInCol: numeric_comparison_exp
  recipient: String_comparison_exp
  swapType: swaptype_comparison_exp
}

"""
order by max() on columns of table "Swap"
"""
input Swap_max_order_by {
  blockTimestamp: order_by
  bondingCurve_id: order_by
  chainId: order_by
  collateralAmount: order_by
  collateralToken: order_by
  db_write_timestamp: order_by
  id: order_by
  initiator: order_by
  issuanceAmount: order_by
  issuanceToken: order_by
  priceInCol: order_by
  recipient: order_by
  swapType: order_by
}

"""
order by min() on columns of table "Swap"
"""
input Swap_min_order_by {
  blockTimestamp: order_by
  bondingCurve_id: order_by
  chainId: order_by
  collateralAmount: order_by
  collateralToken: order_by
  db_write_timestamp: order_by
  id: order_by
  initiator: order_by
  issuanceAmount: order_by
  issuanceToken: order_by
  priceInCol: order_by
  recipient: order_by
  swapType: order_by
}

"""Ordering options when selecting data from "Swap"."""
input Swap_order_by {
  blockTimestamp: order_by
  bondingCurve: BondingCurve_order_by
  bondingCurve_id: order_by
  chainId: order_by
  collateralAmount: order_by
  collateralToken: order_by
  db_write_timestamp: order_by
  id: order_by
  initiator: order_by
  issuanceAmount: order_by
  issuanceToken: order_by
  priceInCol: order_by
  recipient: order_by
  swapType: order_by
}

"""
select columns of table "Swap"
"""
enum Swap_select_column {
  """column name"""
  blockTimestamp

  """column name"""
  bondingCurve_id

  """column name"""
  chainId

  """column name"""
  collateralAmount

  """column name"""
  collateralToken

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  initiator

  """column name"""
  issuanceAmount

  """column name"""
  issuanceToken

  """column name"""
  priceInCol

  """column name"""
  recipient

  """column name"""
  swapType
}

"""
order by stddev() on columns of table "Swap"
"""
input Swap_stddev_order_by {
  blockTimestamp: order_by
  chainId: order_by
  collateralAmount: order_by
  issuanceAmount: order_by
  priceInCol: order_by
}

"""
order by stddev_pop() on columns of table "Swap"
"""
input Swap_stddev_pop_order_by {
  blockTimestamp: order_by
  chainId: order_by
  collateralAmount: order_by
  issuanceAmount: order_by
  priceInCol: order_by
}

"""
order by stddev_samp() on columns of table "Swap"
"""
input Swap_stddev_samp_order_by {
  blockTimestamp: order_by
  chainId: order_by
  collateralAmount: order_by
  issuanceAmount: order_by
  priceInCol: order_by
}

"""
Streaming cursor of the table "Swap"
"""
input Swap_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Swap_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Swap_stream_cursor_value_input {
  blockTimestamp: Int
  bondingCurve_id: String
  chainId: Int
  collateralAmount: numeric
  collateralToken: String
  db_write_timestamp: timestamp
  id: String
  initiator: String
  issuanceAmount: numeric
  issuanceToken: String
  priceInCol: numeric
  recipient: String
  swapType: swaptype
}

"""
order by sum() on columns of table "Swap"
"""
input Swap_sum_order_by {
  blockTimestamp: order_by
  chainId: order_by
  collateralAmount: order_by
  issuanceAmount: order_by
  priceInCol: order_by
}

"""
order by var_pop() on columns of table "Swap"
"""
input Swap_var_pop_order_by {
  blockTimestamp: order_by
  chainId: order_by
  collateralAmount: order_by
  issuanceAmount: order_by
  priceInCol: order_by
}

"""
order by var_samp() on columns of table "Swap"
"""
input Swap_var_samp_order_by {
  blockTimestamp: order_by
  chainId: order_by
  collateralAmount: order_by
  issuanceAmount: order_by
  priceInCol: order_by
}

"""
order by variance() on columns of table "Swap"
"""
input Swap_variance_order_by {
  blockTimestamp: order_by
  chainId: order_by
  collateralAmount: order_by
  issuanceAmount: order_by
  priceInCol: order_by
}

"""
columns and relationships of "Workflow"
"""
type Workflow {
  """An object relationship"""
  authorizer: WorkflowModule
  authorizer_id: String!
  chainId: Int!
  db_write_timestamp: timestamp

  """An object relationship"""
  fundingManager: WorkflowModule
  fundingManager_id: String!
  id: String!
  optionalModules: [String!]
  orchestratorId: numeric!

  """An object relationship"""
  paymentProcessor: WorkflowModule
  paymentProcessor_id: String!
}

"""
columns and relationships of "WorkflowModule"
"""
type WorkflowModule {
  chainId: Int!
  db_write_timestamp: timestamp
  id: String!

  """An object relationship"""
  moduleType: WorkflowModuleType
  moduleType_id: String!
  orchestrator: String!
}

"""
columns and relationships of "WorkflowModuleType"
"""
type WorkflowModuleType {
  beacon: String!
  chainId: Int!
  db_write_timestamp: timestamp
  id: String!
  majorVersion: numeric!
  minorVersion: numeric!
  name: String!
  patchVersion: numeric!
  url: String!
}

"""
Boolean expression to filter rows from the table "WorkflowModuleType". All fields are combined with a logical 'AND'.
"""
input WorkflowModuleType_bool_exp {
  _and: [WorkflowModuleType_bool_exp!]
  _not: WorkflowModuleType_bool_exp
  _or: [WorkflowModuleType_bool_exp!]
  beacon: String_comparison_exp
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  majorVersion: numeric_comparison_exp
  minorVersion: numeric_comparison_exp
  name: String_comparison_exp
  patchVersion: numeric_comparison_exp
  url: String_comparison_exp
}

"""Ordering options when selecting data from "WorkflowModuleType"."""
input WorkflowModuleType_order_by {
  beacon: order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  majorVersion: order_by
  minorVersion: order_by
  name: order_by
  patchVersion: order_by
  url: order_by
}

"""
select columns of table "WorkflowModuleType"
"""
enum WorkflowModuleType_select_column {
  """column name"""
  beacon

  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  majorVersion

  """column name"""
  minorVersion

  """column name"""
  name

  """column name"""
  patchVersion

  """column name"""
  url
}

"""
Streaming cursor of the table "WorkflowModuleType"
"""
input WorkflowModuleType_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: WorkflowModuleType_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input WorkflowModuleType_stream_cursor_value_input {
  beacon: String
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  majorVersion: numeric
  minorVersion: numeric
  name: String
  patchVersion: numeric
  url: String
}

"""
Boolean expression to filter rows from the table "WorkflowModule". All fields are combined with a logical 'AND'.
"""
input WorkflowModule_bool_exp {
  _and: [WorkflowModule_bool_exp!]
  _not: WorkflowModule_bool_exp
  _or: [WorkflowModule_bool_exp!]
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  moduleType: WorkflowModuleType_bool_exp
  moduleType_id: String_comparison_exp
  orchestrator: String_comparison_exp
}

"""Ordering options when selecting data from "WorkflowModule"."""
input WorkflowModule_order_by {
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  moduleType: WorkflowModuleType_order_by
  moduleType_id: order_by
  orchestrator: order_by
}

"""
select columns of table "WorkflowModule"
"""
enum WorkflowModule_select_column {
  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  moduleType_id

  """column name"""
  orchestrator
}

"""
Streaming cursor of the table "WorkflowModule"
"""
input WorkflowModule_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: WorkflowModule_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input WorkflowModule_stream_cursor_value_input {
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  moduleType_id: String
  orchestrator: String
}

"""
Boolean expression to filter rows from the table "Workflow". All fields are combined with a logical 'AND'.
"""
input Workflow_bool_exp {
  _and: [Workflow_bool_exp!]
  _not: Workflow_bool_exp
  _or: [Workflow_bool_exp!]
  authorizer: WorkflowModule_bool_exp
  authorizer_id: String_comparison_exp
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  fundingManager: WorkflowModule_bool_exp
  fundingManager_id: String_comparison_exp
  id: String_comparison_exp
  optionalModules: String_array_comparison_exp
  orchestratorId: numeric_comparison_exp
  paymentProcessor: WorkflowModule_bool_exp
  paymentProcessor_id: String_comparison_exp
}

"""Ordering options when selecting data from "Workflow"."""
input Workflow_order_by {
  authorizer: WorkflowModule_order_by
  authorizer_id: order_by
  chainId: order_by
  db_write_timestamp: order_by
  fundingManager: WorkflowModule_order_by
  fundingManager_id: order_by
  id: order_by
  optionalModules: order_by
  orchestratorId: order_by
  paymentProcessor: WorkflowModule_order_by
  paymentProcessor_id: order_by
}

"""
select columns of table "Workflow"
"""
enum Workflow_select_column {
  """column name"""
  authorizer_id

  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  fundingManager_id

  """column name"""
  id

  """column name"""
  optionalModules

  """column name"""
  orchestratorId

  """column name"""
  paymentProcessor_id
}

"""
Streaming cursor of the table "Workflow"
"""
input Workflow_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Workflow_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Workflow_stream_cursor_value_input {
  authorizer_id: String
  chainId: Int
  db_write_timestamp: timestamp
  fundingManager_id: String
  id: String
  optionalModules: [String!]
  orchestratorId: numeric
  paymentProcessor_id: String
}

"""
columns and relationships of "chain_metadata"
"""
type chain_metadata {
  block_height: Int!
  chain_id: Int!
  end_block: Int
  first_event_block_number: Int
  is_hyper_sync: Boolean!
  latest_fetched_block_number: Int!
  latest_processed_block: Int
  num_batches_fetched: Int!
  num_events_processed: Int
  start_block: Int!
  timestamp_caught_up_to_head_or_endblock: timestamptz
}

"""
Boolean expression to filter rows from the table "chain_metadata". All fields are combined with a logical 'AND'.
"""
input chain_metadata_bool_exp {
  _and: [chain_metadata_bool_exp!]
  _not: chain_metadata_bool_exp
  _or: [chain_metadata_bool_exp!]
  block_height: Int_comparison_exp
  chain_id: Int_comparison_exp
  end_block: Int_comparison_exp
  first_event_block_number: Int_comparison_exp
  is_hyper_sync: Boolean_comparison_exp
  latest_fetched_block_number: Int_comparison_exp
  latest_processed_block: Int_comparison_exp
  num_batches_fetched: Int_comparison_exp
  num_events_processed: Int_comparison_exp
  start_block: Int_comparison_exp
  timestamp_caught_up_to_head_or_endblock: timestamptz_comparison_exp
}

"""Ordering options when selecting data from "chain_metadata"."""
input chain_metadata_order_by {
  block_height: order_by
  chain_id: order_by
  end_block: order_by
  first_event_block_number: order_by
  is_hyper_sync: order_by
  latest_fetched_block_number: order_by
  latest_processed_block: order_by
  num_batches_fetched: order_by
  num_events_processed: order_by
  start_block: order_by
  timestamp_caught_up_to_head_or_endblock: order_by
}

"""
select columns of table "chain_metadata"
"""
enum chain_metadata_select_column {
  """column name"""
  block_height

  """column name"""
  chain_id

  """column name"""
  end_block

  """column name"""
  first_event_block_number

  """column name"""
  is_hyper_sync

  """column name"""
  latest_fetched_block_number

  """column name"""
  latest_processed_block

  """column name"""
  num_batches_fetched

  """column name"""
  num_events_processed

  """column name"""
  start_block

  """column name"""
  timestamp_caught_up_to_head_or_endblock
}

"""
Streaming cursor of the table "chain_metadata"
"""
input chain_metadata_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: chain_metadata_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input chain_metadata_stream_cursor_value_input {
  block_height: Int
  chain_id: Int
  end_block: Int
  first_event_block_number: Int
  is_hyper_sync: Boolean
  latest_fetched_block_number: Int
  latest_processed_block: Int
  num_batches_fetched: Int
  num_events_processed: Int
  start_block: Int
  timestamp_caught_up_to_head_or_endblock: timestamptz
}

scalar contract_type

"""
Boolean expression to compare columns of type "contract_type". All fields are combined with logical 'AND'.
"""
input contract_type_comparison_exp {
  _eq: contract_type
  _gt: contract_type
  _gte: contract_type
  _in: [contract_type!]
  _is_null: Boolean
  _lt: contract_type
  _lte: contract_type
  _neq: contract_type
  _nin: [contract_type!]
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
columns and relationships of "dynamic_contract_registry"
"""
type dynamic_contract_registry {
  chain_id: Int!
  contract_address: String!
  contract_type: contract_type!
  registering_event_block_number: Int!
  registering_event_block_timestamp: Int!
  registering_event_contract_name: String!
  registering_event_log_index: Int!
  registering_event_name: String!
  registering_event_src_address: String!
}

"""
Boolean expression to filter rows from the table "dynamic_contract_registry". All fields are combined with a logical 'AND'.
"""
input dynamic_contract_registry_bool_exp {
  _and: [dynamic_contract_registry_bool_exp!]
  _not: dynamic_contract_registry_bool_exp
  _or: [dynamic_contract_registry_bool_exp!]
  chain_id: Int_comparison_exp
  contract_address: String_comparison_exp
  contract_type: contract_type_comparison_exp
  registering_event_block_number: Int_comparison_exp
  registering_event_block_timestamp: Int_comparison_exp
  registering_event_contract_name: String_comparison_exp
  registering_event_log_index: Int_comparison_exp
  registering_event_name: String_comparison_exp
  registering_event_src_address: String_comparison_exp
}

"""Ordering options when selecting data from "dynamic_contract_registry"."""
input dynamic_contract_registry_order_by {
  chain_id: order_by
  contract_address: order_by
  contract_type: order_by
  registering_event_block_number: order_by
  registering_event_block_timestamp: order_by
  registering_event_contract_name: order_by
  registering_event_log_index: order_by
  registering_event_name: order_by
  registering_event_src_address: order_by
}

"""
select columns of table "dynamic_contract_registry"
"""
enum dynamic_contract_registry_select_column {
  """column name"""
  chain_id

  """column name"""
  contract_address

  """column name"""
  contract_type

  """column name"""
  registering_event_block_number

  """column name"""
  registering_event_block_timestamp

  """column name"""
  registering_event_contract_name

  """column name"""
  registering_event_log_index

  """column name"""
  registering_event_name

  """column name"""
  registering_event_src_address
}

"""
Streaming cursor of the table "dynamic_contract_registry"
"""
input dynamic_contract_registry_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: dynamic_contract_registry_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input dynamic_contract_registry_stream_cursor_value_input {
  chain_id: Int
  contract_address: String
  contract_type: contract_type
  registering_event_block_number: Int
  registering_event_block_timestamp: Int
  registering_event_contract_name: String
  registering_event_log_index: Int
  registering_event_name: String
  registering_event_src_address: String
}

"""
columns and relationships of "end_of_block_range_scanned_data"
"""
type end_of_block_range_scanned_data {
  block_hash: String!
  block_number: Int!
  block_timestamp: Int!
  chain_id: Int!
}

"""
Boolean expression to filter rows from the table "end_of_block_range_scanned_data". All fields are combined with a logical 'AND'.
"""
input end_of_block_range_scanned_data_bool_exp {
  _and: [end_of_block_range_scanned_data_bool_exp!]
  _not: end_of_block_range_scanned_data_bool_exp
  _or: [end_of_block_range_scanned_data_bool_exp!]
  block_hash: String_comparison_exp
  block_number: Int_comparison_exp
  block_timestamp: Int_comparison_exp
  chain_id: Int_comparison_exp
}

"""
Ordering options when selecting data from "end_of_block_range_scanned_data".
"""
input end_of_block_range_scanned_data_order_by {
  block_hash: order_by
  block_number: order_by
  block_timestamp: order_by
  chain_id: order_by
}

"""
select columns of table "end_of_block_range_scanned_data"
"""
enum end_of_block_range_scanned_data_select_column {
  """column name"""
  block_hash

  """column name"""
  block_number

  """column name"""
  block_timestamp

  """column name"""
  chain_id
}

"""
Streaming cursor of the table "end_of_block_range_scanned_data"
"""
input end_of_block_range_scanned_data_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: end_of_block_range_scanned_data_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input end_of_block_range_scanned_data_stream_cursor_value_input {
  block_hash: String
  block_number: Int
  block_timestamp: Int
  chain_id: Int
}

"""
columns and relationships of "entity_history"
"""
type entity_history {
  block_number: Int!
  block_timestamp: Int!
  chain_id: Int!
  entity_id: String!
  entity_type: entity_type!

  """An object relationship"""
  event: raw_events
  log_index: Int!
  params(
    """JSON select path"""
    path: String
  ): jsonb
  previous_block_number: Int
  previous_block_timestamp: Int
  previous_chain_id: Int
  previous_log_index: Int
}

"""
order by aggregate values of table "entity_history"
"""
input entity_history_aggregate_order_by {
  avg: entity_history_avg_order_by
  count: order_by
  max: entity_history_max_order_by
  min: entity_history_min_order_by
  stddev: entity_history_stddev_order_by
  stddev_pop: entity_history_stddev_pop_order_by
  stddev_samp: entity_history_stddev_samp_order_by
  sum: entity_history_sum_order_by
  var_pop: entity_history_var_pop_order_by
  var_samp: entity_history_var_samp_order_by
  variance: entity_history_variance_order_by
}

"""
order by avg() on columns of table "entity_history"
"""
input entity_history_avg_order_by {
  block_number: order_by
  block_timestamp: order_by
  chain_id: order_by
  log_index: order_by
  previous_block_number: order_by
  previous_block_timestamp: order_by
  previous_chain_id: order_by
  previous_log_index: order_by
}

"""
Boolean expression to filter rows from the table "entity_history". All fields are combined with a logical 'AND'.
"""
input entity_history_bool_exp {
  _and: [entity_history_bool_exp!]
  _not: entity_history_bool_exp
  _or: [entity_history_bool_exp!]
  block_number: Int_comparison_exp
  block_timestamp: Int_comparison_exp
  chain_id: Int_comparison_exp
  entity_id: String_comparison_exp
  entity_type: entity_type_comparison_exp
  event: raw_events_bool_exp
  log_index: Int_comparison_exp
  params: jsonb_comparison_exp
  previous_block_number: Int_comparison_exp
  previous_block_timestamp: Int_comparison_exp
  previous_chain_id: Int_comparison_exp
  previous_log_index: Int_comparison_exp
}

"""
columns and relationships of "entity_history_filter"
"""
type entity_history_filter {
  block_number: Int!
  block_timestamp: Int!
  chain_id: Int!
  entity_id: String!
  entity_type: entity_type!

  """An object relationship"""
  event: raw_events
  log_index: Int!
  new_val(
    """JSON select path"""
    path: String
  ): jsonb
  old_val(
    """JSON select path"""
    path: String
  ): jsonb
  previous_block_number: Int
  previous_log_index: Int!
}

"""
Boolean expression to filter rows from the table "entity_history_filter". All fields are combined with a logical 'AND'.
"""
input entity_history_filter_bool_exp {
  _and: [entity_history_filter_bool_exp!]
  _not: entity_history_filter_bool_exp
  _or: [entity_history_filter_bool_exp!]
  block_number: Int_comparison_exp
  block_timestamp: Int_comparison_exp
  chain_id: Int_comparison_exp
  entity_id: String_comparison_exp
  entity_type: entity_type_comparison_exp
  event: raw_events_bool_exp
  log_index: Int_comparison_exp
  new_val: jsonb_comparison_exp
  old_val: jsonb_comparison_exp
  previous_block_number: Int_comparison_exp
  previous_log_index: Int_comparison_exp
}

"""Ordering options when selecting data from "entity_history_filter"."""
input entity_history_filter_order_by {
  block_number: order_by
  block_timestamp: order_by
  chain_id: order_by
  entity_id: order_by
  entity_type: order_by
  event: raw_events_order_by
  log_index: order_by
  new_val: order_by
  old_val: order_by
  previous_block_number: order_by
  previous_log_index: order_by
}

"""
select columns of table "entity_history_filter"
"""
enum entity_history_filter_select_column {
  """column name"""
  block_number

  """column name"""
  block_timestamp

  """column name"""
  chain_id

  """column name"""
  entity_id

  """column name"""
  entity_type

  """column name"""
  log_index

  """column name"""
  new_val

  """column name"""
  old_val

  """column name"""
  previous_block_number

  """column name"""
  previous_log_index
}

"""
Streaming cursor of the table "entity_history_filter"
"""
input entity_history_filter_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: entity_history_filter_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input entity_history_filter_stream_cursor_value_input {
  block_number: Int
  block_timestamp: Int
  chain_id: Int
  entity_id: String
  entity_type: entity_type
  log_index: Int
  new_val: jsonb
  old_val: jsonb
  previous_block_number: Int
  previous_log_index: Int
}

"""
order by max() on columns of table "entity_history"
"""
input entity_history_max_order_by {
  block_number: order_by
  block_timestamp: order_by
  chain_id: order_by
  entity_id: order_by
  entity_type: order_by
  log_index: order_by
  previous_block_number: order_by
  previous_block_timestamp: order_by
  previous_chain_id: order_by
  previous_log_index: order_by
}

"""
order by min() on columns of table "entity_history"
"""
input entity_history_min_order_by {
  block_number: order_by
  block_timestamp: order_by
  chain_id: order_by
  entity_id: order_by
  entity_type: order_by
  log_index: order_by
  previous_block_number: order_by
  previous_block_timestamp: order_by
  previous_chain_id: order_by
  previous_log_index: order_by
}

"""Ordering options when selecting data from "entity_history"."""
input entity_history_order_by {
  block_number: order_by
  block_timestamp: order_by
  chain_id: order_by
  entity_id: order_by
  entity_type: order_by
  event: raw_events_order_by
  log_index: order_by
  params: order_by
  previous_block_number: order_by
  previous_block_timestamp: order_by
  previous_chain_id: order_by
  previous_log_index: order_by
}

"""
select columns of table "entity_history"
"""
enum entity_history_select_column {
  """column name"""
  block_number

  """column name"""
  block_timestamp

  """column name"""
  chain_id

  """column name"""
  entity_id

  """column name"""
  entity_type

  """column name"""
  log_index

  """column name"""
  params

  """column name"""
  previous_block_number

  """column name"""
  previous_block_timestamp

  """column name"""
  previous_chain_id

  """column name"""
  previous_log_index
}

"""
order by stddev() on columns of table "entity_history"
"""
input entity_history_stddev_order_by {
  block_number: order_by
  block_timestamp: order_by
  chain_id: order_by
  log_index: order_by
  previous_block_number: order_by
  previous_block_timestamp: order_by
  previous_chain_id: order_by
  previous_log_index: order_by
}

"""
order by stddev_pop() on columns of table "entity_history"
"""
input entity_history_stddev_pop_order_by {
  block_number: order_by
  block_timestamp: order_by
  chain_id: order_by
  log_index: order_by
  previous_block_number: order_by
  previous_block_timestamp: order_by
  previous_chain_id: order_by
  previous_log_index: order_by
}

"""
order by stddev_samp() on columns of table "entity_history"
"""
input entity_history_stddev_samp_order_by {
  block_number: order_by
  block_timestamp: order_by
  chain_id: order_by
  log_index: order_by
  previous_block_number: order_by
  previous_block_timestamp: order_by
  previous_chain_id: order_by
  previous_log_index: order_by
}

"""
Streaming cursor of the table "entity_history"
"""
input entity_history_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: entity_history_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input entity_history_stream_cursor_value_input {
  block_number: Int
  block_timestamp: Int
  chain_id: Int
  entity_id: String
  entity_type: entity_type
  log_index: Int
  params: jsonb
  previous_block_number: Int
  previous_block_timestamp: Int
  previous_chain_id: Int
  previous_log_index: Int
}

"""
order by sum() on columns of table "entity_history"
"""
input entity_history_sum_order_by {
  block_number: order_by
  block_timestamp: order_by
  chain_id: order_by
  log_index: order_by
  previous_block_number: order_by
  previous_block_timestamp: order_by
  previous_chain_id: order_by
  previous_log_index: order_by
}

"""
order by var_pop() on columns of table "entity_history"
"""
input entity_history_var_pop_order_by {
  block_number: order_by
  block_timestamp: order_by
  chain_id: order_by
  log_index: order_by
  previous_block_number: order_by
  previous_block_timestamp: order_by
  previous_chain_id: order_by
  previous_log_index: order_by
}

"""
order by var_samp() on columns of table "entity_history"
"""
input entity_history_var_samp_order_by {
  block_number: order_by
  block_timestamp: order_by
  chain_id: order_by
  log_index: order_by
  previous_block_number: order_by
  previous_block_timestamp: order_by
  previous_chain_id: order_by
  previous_log_index: order_by
}

"""
order by variance() on columns of table "entity_history"
"""
input entity_history_variance_order_by {
  block_number: order_by
  block_timestamp: order_by
  chain_id: order_by
  log_index: order_by
  previous_block_number: order_by
  previous_block_timestamp: order_by
  previous_chain_id: order_by
  previous_log_index: order_by
}

scalar entity_type

"""
Boolean expression to compare columns of type "entity_type". All fields are combined with logical 'AND'.
"""
input entity_type_comparison_exp {
  _eq: entity_type
  _gt: entity_type
  _gte: entity_type
  _in: [entity_type!]
  _is_null: Boolean
  _lt: entity_type
  _lte: entity_type
  _neq: entity_type
  _nin: [entity_type!]
}

"""
columns and relationships of "event_sync_state"
"""
type event_sync_state {
  block_number: Int!
  block_timestamp: Int!
  chain_id: Int!
  is_pre_registering_dynamic_contracts: Boolean!
  log_index: Int!
}

"""
Boolean expression to filter rows from the table "event_sync_state". All fields are combined with a logical 'AND'.
"""
input event_sync_state_bool_exp {
  _and: [event_sync_state_bool_exp!]
  _not: event_sync_state_bool_exp
  _or: [event_sync_state_bool_exp!]
  block_number: Int_comparison_exp
  block_timestamp: Int_comparison_exp
  chain_id: Int_comparison_exp
  is_pre_registering_dynamic_contracts: Boolean_comparison_exp
  log_index: Int_comparison_exp
}

"""Ordering options when selecting data from "event_sync_state"."""
input event_sync_state_order_by {
  block_number: order_by
  block_timestamp: order_by
  chain_id: order_by
  is_pre_registering_dynamic_contracts: order_by
  log_index: order_by
}

"""
select columns of table "event_sync_state"
"""
enum event_sync_state_select_column {
  """column name"""
  block_number

  """column name"""
  block_timestamp

  """column name"""
  chain_id

  """column name"""
  is_pre_registering_dynamic_contracts

  """column name"""
  log_index
}

"""
Streaming cursor of the table "event_sync_state"
"""
input event_sync_state_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: event_sync_state_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input event_sync_state_stream_cursor_value_input {
  block_number: Int
  block_timestamp: Int
  chain_id: Int
  is_pre_registering_dynamic_contracts: Boolean
  log_index: Int
}

input get_entity_history_filter_args {
  end_block: Int
  end_chain_id: Int
  end_log_index: Int
  end_timestamp: Int
  start_block: Int
  start_chain_id: Int
  start_log_index: Int
  start_timestamp: Int
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "persisted_state"
"""
type persisted_state {
  abi_files_hash: String!
  config_hash: String!
  envio_version: String!
  handler_files_hash: String!
  id: Int!
  schema_hash: String!
}

"""
Boolean expression to filter rows from the table "persisted_state". All fields are combined with a logical 'AND'.
"""
input persisted_state_bool_exp {
  _and: [persisted_state_bool_exp!]
  _not: persisted_state_bool_exp
  _or: [persisted_state_bool_exp!]
  abi_files_hash: String_comparison_exp
  config_hash: String_comparison_exp
  envio_version: String_comparison_exp
  handler_files_hash: String_comparison_exp
  id: Int_comparison_exp
  schema_hash: String_comparison_exp
}

"""Ordering options when selecting data from "persisted_state"."""
input persisted_state_order_by {
  abi_files_hash: order_by
  config_hash: order_by
  envio_version: order_by
  handler_files_hash: order_by
  id: order_by
  schema_hash: order_by
}

"""
select columns of table "persisted_state"
"""
enum persisted_state_select_column {
  """column name"""
  abi_files_hash

  """column name"""
  config_hash

  """column name"""
  envio_version

  """column name"""
  handler_files_hash

  """column name"""
  id

  """column name"""
  schema_hash
}

"""
Streaming cursor of the table "persisted_state"
"""
input persisted_state_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: persisted_state_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input persisted_state_stream_cursor_value_input {
  abi_files_hash: String
  config_hash: String
  envio_version: String
  handler_files_hash: String
  id: Int
  schema_hash: String
}

type query_root {
  """
  fetch data from the table: "BondingCurve"
  """
  BondingCurve(
    """distinct select on columns"""
    distinct_on: [BondingCurve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BondingCurve_order_by!]

    """filter the rows returned"""
    where: BondingCurve_bool_exp
  ): [BondingCurve!]!

  """fetch data from the table: "BondingCurve" using primary key columns"""
  BondingCurve_by_pk(id: String!): BondingCurve

  """
  fetch data from the table: "FeeClaim"
  """
  FeeClaim(
    """distinct select on columns"""
    distinct_on: [FeeClaim_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [FeeClaim_order_by!]

    """filter the rows returned"""
    where: FeeClaim_bool_exp
  ): [FeeClaim!]!

  """fetch data from the table: "FeeClaim" using primary key columns"""
  FeeClaim_by_pk(id: String!): FeeClaim

  """
  fetch data from the table: "LinearVesting"
  """
  LinearVesting(
    """distinct select on columns"""
    distinct_on: [LinearVesting_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [LinearVesting_order_by!]

    """filter the rows returned"""
    where: LinearVesting_bool_exp
  ): [LinearVesting!]!

  """fetch data from the table: "LinearVesting" using primary key columns"""
  LinearVesting_by_pk(id: String!): LinearVesting

  """
  fetch data from the table: "StreamingPaymentProcessor"
  """
  StreamingPaymentProcessor(
    """distinct select on columns"""
    distinct_on: [StreamingPaymentProcessor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [StreamingPaymentProcessor_order_by!]

    """filter the rows returned"""
    where: StreamingPaymentProcessor_bool_exp
  ): [StreamingPaymentProcessor!]!

  """
  fetch data from the table: "StreamingPaymentProcessor" using primary key columns
  """
  StreamingPaymentProcessor_by_pk(id: String!): StreamingPaymentProcessor

  """
  fetch data from the table: "Swap"
  """
  Swap(
    """distinct select on columns"""
    distinct_on: [Swap_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Swap_order_by!]

    """filter the rows returned"""
    where: Swap_bool_exp
  ): [Swap!]!

  """fetch data from the table: "Swap" using primary key columns"""
  Swap_by_pk(id: String!): Swap

  """
  fetch data from the table: "Workflow"
  """
  Workflow(
    """distinct select on columns"""
    distinct_on: [Workflow_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Workflow_order_by!]

    """filter the rows returned"""
    where: Workflow_bool_exp
  ): [Workflow!]!

  """
  fetch data from the table: "WorkflowModule"
  """
  WorkflowModule(
    """distinct select on columns"""
    distinct_on: [WorkflowModule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [WorkflowModule_order_by!]

    """filter the rows returned"""
    where: WorkflowModule_bool_exp
  ): [WorkflowModule!]!

  """
  fetch data from the table: "WorkflowModuleType"
  """
  WorkflowModuleType(
    """distinct select on columns"""
    distinct_on: [WorkflowModuleType_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [WorkflowModuleType_order_by!]

    """filter the rows returned"""
    where: WorkflowModuleType_bool_exp
  ): [WorkflowModuleType!]!

  """
  fetch data from the table: "WorkflowModuleType" using primary key columns
  """
  WorkflowModuleType_by_pk(id: String!): WorkflowModuleType

  """fetch data from the table: "WorkflowModule" using primary key columns"""
  WorkflowModule_by_pk(id: String!): WorkflowModule

  """fetch data from the table: "Workflow" using primary key columns"""
  Workflow_by_pk(id: String!): Workflow

  """
  fetch data from the table: "chain_metadata"
  """
  chain_metadata(
    """distinct select on columns"""
    distinct_on: [chain_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chain_metadata_order_by!]

    """filter the rows returned"""
    where: chain_metadata_bool_exp
  ): [chain_metadata!]!

  """fetch data from the table: "chain_metadata" using primary key columns"""
  chain_metadata_by_pk(chain_id: Int!): chain_metadata

  """
  fetch data from the table: "dynamic_contract_registry"
  """
  dynamic_contract_registry(
    """distinct select on columns"""
    distinct_on: [dynamic_contract_registry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dynamic_contract_registry_order_by!]

    """filter the rows returned"""
    where: dynamic_contract_registry_bool_exp
  ): [dynamic_contract_registry!]!

  """
  fetch data from the table: "dynamic_contract_registry" using primary key columns
  """
  dynamic_contract_registry_by_pk(chain_id: Int!, contract_address: String!): dynamic_contract_registry

  """
  fetch data from the table: "end_of_block_range_scanned_data"
  """
  end_of_block_range_scanned_data(
    """distinct select on columns"""
    distinct_on: [end_of_block_range_scanned_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [end_of_block_range_scanned_data_order_by!]

    """filter the rows returned"""
    where: end_of_block_range_scanned_data_bool_exp
  ): [end_of_block_range_scanned_data!]!

  """
  fetch data from the table: "end_of_block_range_scanned_data" using primary key columns
  """
  end_of_block_range_scanned_data_by_pk(block_number: Int!, chain_id: Int!): end_of_block_range_scanned_data

  """
  fetch data from the table: "entity_history"
  """
  entity_history(
    """distinct select on columns"""
    distinct_on: [entity_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entity_history_order_by!]

    """filter the rows returned"""
    where: entity_history_bool_exp
  ): [entity_history!]!

  """fetch data from the table: "entity_history" using primary key columns"""
  entity_history_by_pk(block_number: Int!, block_timestamp: Int!, chain_id: Int!, entity_id: String!, entity_type: entity_type!, log_index: Int!): entity_history

  """
  fetch data from the table: "entity_history_filter"
  """
  entity_history_filter(
    """distinct select on columns"""
    distinct_on: [entity_history_filter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entity_history_filter_order_by!]

    """filter the rows returned"""
    where: entity_history_filter_bool_exp
  ): [entity_history_filter!]!

  """
  fetch data from the table: "entity_history_filter" using primary key columns
  """
  entity_history_filter_by_pk(block_number: Int!, block_timestamp: Int!, chain_id: Int!, entity_id: String!, entity_type: entity_type!, log_index: Int!, previous_log_index: Int!): entity_history_filter

  """
  fetch data from the table: "event_sync_state"
  """
  event_sync_state(
    """distinct select on columns"""
    distinct_on: [event_sync_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_sync_state_order_by!]

    """filter the rows returned"""
    where: event_sync_state_bool_exp
  ): [event_sync_state!]!

  """
  fetch data from the table: "event_sync_state" using primary key columns
  """
  event_sync_state_by_pk(chain_id: Int!): event_sync_state

  """This function helps search for articles"""
  get_entity_history_filter(
    """
    input parameters for function "get_entity_history_filter"
    """
    args: get_entity_history_filter_args!

    """distinct select on columns"""
    distinct_on: [entity_history_filter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entity_history_filter_order_by!]

    """filter the rows returned"""
    where: entity_history_filter_bool_exp
  ): [entity_history_filter!]!

  """
  fetch data from the table: "persisted_state"
  """
  persisted_state(
    """distinct select on columns"""
    distinct_on: [persisted_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [persisted_state_order_by!]

    """filter the rows returned"""
    where: persisted_state_bool_exp
  ): [persisted_state!]!

  """fetch data from the table: "persisted_state" using primary key columns"""
  persisted_state_by_pk(id: Int!): persisted_state

  """
  fetch data from the table: "raw_events"
  """
  raw_events(
    """distinct select on columns"""
    distinct_on: [raw_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [raw_events_order_by!]

    """filter the rows returned"""
    where: raw_events_bool_exp
  ): [raw_events!]!

  """fetch data from the table: "raw_events" using primary key columns"""
  raw_events_by_pk(chain_id: Int!, event_id: numeric!): raw_events
}

"""
columns and relationships of "raw_events"
"""
type raw_events {
  block_fields(
    """JSON select path"""
    path: String
  ): jsonb!
  block_hash: String!
  block_number: Int!
  block_timestamp: Int!
  chain_id: Int!
  contract_name: String!
  db_write_timestamp: timestamp

  """An array relationship"""
  event_history(
    """distinct select on columns"""
    distinct_on: [entity_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entity_history_order_by!]

    """filter the rows returned"""
    where: entity_history_bool_exp
  ): [entity_history!]!
  event_id: numeric!
  event_name: String!
  log_index: Int!
  params(
    """JSON select path"""
    path: String
  ): jsonb!
  src_address: String!
  transaction_fields(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
Boolean expression to filter rows from the table "raw_events". All fields are combined with a logical 'AND'.
"""
input raw_events_bool_exp {
  _and: [raw_events_bool_exp!]
  _not: raw_events_bool_exp
  _or: [raw_events_bool_exp!]
  block_fields: jsonb_comparison_exp
  block_hash: String_comparison_exp
  block_number: Int_comparison_exp
  block_timestamp: Int_comparison_exp
  chain_id: Int_comparison_exp
  contract_name: String_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  event_history: entity_history_bool_exp
  event_id: numeric_comparison_exp
  event_name: String_comparison_exp
  log_index: Int_comparison_exp
  params: jsonb_comparison_exp
  src_address: String_comparison_exp
  transaction_fields: jsonb_comparison_exp
}

"""Ordering options when selecting data from "raw_events"."""
input raw_events_order_by {
  block_fields: order_by
  block_hash: order_by
  block_number: order_by
  block_timestamp: order_by
  chain_id: order_by
  contract_name: order_by
  db_write_timestamp: order_by
  event_history_aggregate: entity_history_aggregate_order_by
  event_id: order_by
  event_name: order_by
  log_index: order_by
  params: order_by
  src_address: order_by
  transaction_fields: order_by
}

"""
select columns of table "raw_events"
"""
enum raw_events_select_column {
  """column name"""
  block_fields

  """column name"""
  block_hash

  """column name"""
  block_number

  """column name"""
  block_timestamp

  """column name"""
  chain_id

  """column name"""
  contract_name

  """column name"""
  db_write_timestamp

  """column name"""
  event_id

  """column name"""
  event_name

  """column name"""
  log_index

  """column name"""
  params

  """column name"""
  src_address

  """column name"""
  transaction_fields
}

"""
Streaming cursor of the table "raw_events"
"""
input raw_events_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: raw_events_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input raw_events_stream_cursor_value_input {
  block_fields: jsonb
  block_hash: String
  block_number: Int
  block_timestamp: Int
  chain_id: Int
  contract_name: String
  db_write_timestamp: timestamp
  event_id: numeric
  event_name: String
  log_index: Int
  params: jsonb
  src_address: String
  transaction_fields: jsonb
}

type subscription_root {
  """
  fetch data from the table: "BondingCurve"
  """
  BondingCurve(
    """distinct select on columns"""
    distinct_on: [BondingCurve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BondingCurve_order_by!]

    """filter the rows returned"""
    where: BondingCurve_bool_exp
  ): [BondingCurve!]!

  """fetch data from the table: "BondingCurve" using primary key columns"""
  BondingCurve_by_pk(id: String!): BondingCurve

  """
  fetch data from the table in a streaming manner: "BondingCurve"
  """
  BondingCurve_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [BondingCurve_stream_cursor_input]!

    """filter the rows returned"""
    where: BondingCurve_bool_exp
  ): [BondingCurve!]!

  """
  fetch data from the table: "FeeClaim"
  """
  FeeClaim(
    """distinct select on columns"""
    distinct_on: [FeeClaim_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [FeeClaim_order_by!]

    """filter the rows returned"""
    where: FeeClaim_bool_exp
  ): [FeeClaim!]!

  """fetch data from the table: "FeeClaim" using primary key columns"""
  FeeClaim_by_pk(id: String!): FeeClaim

  """
  fetch data from the table in a streaming manner: "FeeClaim"
  """
  FeeClaim_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [FeeClaim_stream_cursor_input]!

    """filter the rows returned"""
    where: FeeClaim_bool_exp
  ): [FeeClaim!]!

  """
  fetch data from the table: "LinearVesting"
  """
  LinearVesting(
    """distinct select on columns"""
    distinct_on: [LinearVesting_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [LinearVesting_order_by!]

    """filter the rows returned"""
    where: LinearVesting_bool_exp
  ): [LinearVesting!]!

  """fetch data from the table: "LinearVesting" using primary key columns"""
  LinearVesting_by_pk(id: String!): LinearVesting

  """
  fetch data from the table in a streaming manner: "LinearVesting"
  """
  LinearVesting_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [LinearVesting_stream_cursor_input]!

    """filter the rows returned"""
    where: LinearVesting_bool_exp
  ): [LinearVesting!]!

  """
  fetch data from the table: "StreamingPaymentProcessor"
  """
  StreamingPaymentProcessor(
    """distinct select on columns"""
    distinct_on: [StreamingPaymentProcessor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [StreamingPaymentProcessor_order_by!]

    """filter the rows returned"""
    where: StreamingPaymentProcessor_bool_exp
  ): [StreamingPaymentProcessor!]!

  """
  fetch data from the table: "StreamingPaymentProcessor" using primary key columns
  """
  StreamingPaymentProcessor_by_pk(id: String!): StreamingPaymentProcessor

  """
  fetch data from the table in a streaming manner: "StreamingPaymentProcessor"
  """
  StreamingPaymentProcessor_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [StreamingPaymentProcessor_stream_cursor_input]!

    """filter the rows returned"""
    where: StreamingPaymentProcessor_bool_exp
  ): [StreamingPaymentProcessor!]!

  """
  fetch data from the table: "Swap"
  """
  Swap(
    """distinct select on columns"""
    distinct_on: [Swap_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Swap_order_by!]

    """filter the rows returned"""
    where: Swap_bool_exp
  ): [Swap!]!

  """fetch data from the table: "Swap" using primary key columns"""
  Swap_by_pk(id: String!): Swap

  """
  fetch data from the table in a streaming manner: "Swap"
  """
  Swap_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Swap_stream_cursor_input]!

    """filter the rows returned"""
    where: Swap_bool_exp
  ): [Swap!]!

  """
  fetch data from the table: "Workflow"
  """
  Workflow(
    """distinct select on columns"""
    distinct_on: [Workflow_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Workflow_order_by!]

    """filter the rows returned"""
    where: Workflow_bool_exp
  ): [Workflow!]!

  """
  fetch data from the table: "WorkflowModule"
  """
  WorkflowModule(
    """distinct select on columns"""
    distinct_on: [WorkflowModule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [WorkflowModule_order_by!]

    """filter the rows returned"""
    where: WorkflowModule_bool_exp
  ): [WorkflowModule!]!

  """
  fetch data from the table: "WorkflowModuleType"
  """
  WorkflowModuleType(
    """distinct select on columns"""
    distinct_on: [WorkflowModuleType_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [WorkflowModuleType_order_by!]

    """filter the rows returned"""
    where: WorkflowModuleType_bool_exp
  ): [WorkflowModuleType!]!

  """
  fetch data from the table: "WorkflowModuleType" using primary key columns
  """
  WorkflowModuleType_by_pk(id: String!): WorkflowModuleType

  """
  fetch data from the table in a streaming manner: "WorkflowModuleType"
  """
  WorkflowModuleType_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [WorkflowModuleType_stream_cursor_input]!

    """filter the rows returned"""
    where: WorkflowModuleType_bool_exp
  ): [WorkflowModuleType!]!

  """fetch data from the table: "WorkflowModule" using primary key columns"""
  WorkflowModule_by_pk(id: String!): WorkflowModule

  """
  fetch data from the table in a streaming manner: "WorkflowModule"
  """
  WorkflowModule_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [WorkflowModule_stream_cursor_input]!

    """filter the rows returned"""
    where: WorkflowModule_bool_exp
  ): [WorkflowModule!]!

  """fetch data from the table: "Workflow" using primary key columns"""
  Workflow_by_pk(id: String!): Workflow

  """
  fetch data from the table in a streaming manner: "Workflow"
  """
  Workflow_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Workflow_stream_cursor_input]!

    """filter the rows returned"""
    where: Workflow_bool_exp
  ): [Workflow!]!

  """
  fetch data from the table: "chain_metadata"
  """
  chain_metadata(
    """distinct select on columns"""
    distinct_on: [chain_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chain_metadata_order_by!]

    """filter the rows returned"""
    where: chain_metadata_bool_exp
  ): [chain_metadata!]!

  """fetch data from the table: "chain_metadata" using primary key columns"""
  chain_metadata_by_pk(chain_id: Int!): chain_metadata

  """
  fetch data from the table in a streaming manner: "chain_metadata"
  """
  chain_metadata_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [chain_metadata_stream_cursor_input]!

    """filter the rows returned"""
    where: chain_metadata_bool_exp
  ): [chain_metadata!]!

  """
  fetch data from the table: "dynamic_contract_registry"
  """
  dynamic_contract_registry(
    """distinct select on columns"""
    distinct_on: [dynamic_contract_registry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dynamic_contract_registry_order_by!]

    """filter the rows returned"""
    where: dynamic_contract_registry_bool_exp
  ): [dynamic_contract_registry!]!

  """
  fetch data from the table: "dynamic_contract_registry" using primary key columns
  """
  dynamic_contract_registry_by_pk(chain_id: Int!, contract_address: String!): dynamic_contract_registry

  """
  fetch data from the table in a streaming manner: "dynamic_contract_registry"
  """
  dynamic_contract_registry_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [dynamic_contract_registry_stream_cursor_input]!

    """filter the rows returned"""
    where: dynamic_contract_registry_bool_exp
  ): [dynamic_contract_registry!]!

  """
  fetch data from the table: "end_of_block_range_scanned_data"
  """
  end_of_block_range_scanned_data(
    """distinct select on columns"""
    distinct_on: [end_of_block_range_scanned_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [end_of_block_range_scanned_data_order_by!]

    """filter the rows returned"""
    where: end_of_block_range_scanned_data_bool_exp
  ): [end_of_block_range_scanned_data!]!

  """
  fetch data from the table: "end_of_block_range_scanned_data" using primary key columns
  """
  end_of_block_range_scanned_data_by_pk(block_number: Int!, chain_id: Int!): end_of_block_range_scanned_data

  """
  fetch data from the table in a streaming manner: "end_of_block_range_scanned_data"
  """
  end_of_block_range_scanned_data_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [end_of_block_range_scanned_data_stream_cursor_input]!

    """filter the rows returned"""
    where: end_of_block_range_scanned_data_bool_exp
  ): [end_of_block_range_scanned_data!]!

  """
  fetch data from the table: "entity_history"
  """
  entity_history(
    """distinct select on columns"""
    distinct_on: [entity_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entity_history_order_by!]

    """filter the rows returned"""
    where: entity_history_bool_exp
  ): [entity_history!]!

  """fetch data from the table: "entity_history" using primary key columns"""
  entity_history_by_pk(block_number: Int!, block_timestamp: Int!, chain_id: Int!, entity_id: String!, entity_type: entity_type!, log_index: Int!): entity_history

  """
  fetch data from the table: "entity_history_filter"
  """
  entity_history_filter(
    """distinct select on columns"""
    distinct_on: [entity_history_filter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entity_history_filter_order_by!]

    """filter the rows returned"""
    where: entity_history_filter_bool_exp
  ): [entity_history_filter!]!

  """
  fetch data from the table: "entity_history_filter" using primary key columns
  """
  entity_history_filter_by_pk(block_number: Int!, block_timestamp: Int!, chain_id: Int!, entity_id: String!, entity_type: entity_type!, log_index: Int!, previous_log_index: Int!): entity_history_filter

  """
  fetch data from the table in a streaming manner: "entity_history_filter"
  """
  entity_history_filter_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [entity_history_filter_stream_cursor_input]!

    """filter the rows returned"""
    where: entity_history_filter_bool_exp
  ): [entity_history_filter!]!

  """
  fetch data from the table in a streaming manner: "entity_history"
  """
  entity_history_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [entity_history_stream_cursor_input]!

    """filter the rows returned"""
    where: entity_history_bool_exp
  ): [entity_history!]!

  """
  fetch data from the table: "event_sync_state"
  """
  event_sync_state(
    """distinct select on columns"""
    distinct_on: [event_sync_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_sync_state_order_by!]

    """filter the rows returned"""
    where: event_sync_state_bool_exp
  ): [event_sync_state!]!

  """
  fetch data from the table: "event_sync_state" using primary key columns
  """
  event_sync_state_by_pk(chain_id: Int!): event_sync_state

  """
  fetch data from the table in a streaming manner: "event_sync_state"
  """
  event_sync_state_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [event_sync_state_stream_cursor_input]!

    """filter the rows returned"""
    where: event_sync_state_bool_exp
  ): [event_sync_state!]!

  """This function helps search for articles"""
  get_entity_history_filter(
    """
    input parameters for function "get_entity_history_filter"
    """
    args: get_entity_history_filter_args!

    """distinct select on columns"""
    distinct_on: [entity_history_filter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entity_history_filter_order_by!]

    """filter the rows returned"""
    where: entity_history_filter_bool_exp
  ): [entity_history_filter!]!

  """
  fetch data from the table: "persisted_state"
  """
  persisted_state(
    """distinct select on columns"""
    distinct_on: [persisted_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [persisted_state_order_by!]

    """filter the rows returned"""
    where: persisted_state_bool_exp
  ): [persisted_state!]!

  """fetch data from the table: "persisted_state" using primary key columns"""
  persisted_state_by_pk(id: Int!): persisted_state

  """
  fetch data from the table in a streaming manner: "persisted_state"
  """
  persisted_state_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [persisted_state_stream_cursor_input]!

    """filter the rows returned"""
    where: persisted_state_bool_exp
  ): [persisted_state!]!

  """
  fetch data from the table: "raw_events"
  """
  raw_events(
    """distinct select on columns"""
    distinct_on: [raw_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [raw_events_order_by!]

    """filter the rows returned"""
    where: raw_events_bool_exp
  ): [raw_events!]!

  """fetch data from the table: "raw_events" using primary key columns"""
  raw_events_by_pk(chain_id: Int!, event_id: numeric!): raw_events

  """
  fetch data from the table in a streaming manner: "raw_events"
  """
  raw_events_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [raw_events_stream_cursor_input]!

    """filter the rows returned"""
    where: raw_events_bool_exp
  ): [raw_events!]!
}

scalar swaptype

"""
Boolean expression to compare columns of type "swaptype". All fields are combined with logical 'AND'.
"""
input swaptype_comparison_exp {
  _eq: swaptype
  _gt: swaptype
  _gte: swaptype
  _in: [swaptype!]
  _is_null: Boolean
  _lt: swaptype
  _lte: swaptype
  _neq: swaptype
  _nin: [swaptype!]
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

scalar vestingstatus

"""
Boolean expression to compare columns of type "vestingstatus". All fields are combined with logical 'AND'.
"""
input vestingstatus_comparison_exp {
  _eq: vestingstatus
  _gt: vestingstatus
  _gte: vestingstatus
  _in: [vestingstatus!]
  _is_null: Boolean
  _lt: vestingstatus
  _lte: vestingstatus
  _neq: vestingstatus
  _nin: [vestingstatus!]
}